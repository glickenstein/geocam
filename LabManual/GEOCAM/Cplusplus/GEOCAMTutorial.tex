
\documentclass{amsart}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{amstext}
\usepackage{eucal}
\usepackage{verbatim}
\usepackage{hyperref}

\setcounter{MaxMatrixCols}{10}
%TCIDATA{OutputFilter=Latex.dll}
%TCIDATA{Version=5.00.0.2606}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=Manual}
%TCIDATA{LastRevised=Tuesday, March 02, 2010 16:19:15}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{Language=American English}

\providecommand{\U}[1]{\protect\rule{.1in}{.1in}}
\newtheorem{theorem}{Theorem}
\theoremstyle{plain}
\newtheorem{acknowledgement}{Acknowledgement}
\newtheorem{algorithm}{Algorithm}
\newtheorem{axiom}{Axiom}
\newtheorem{case}{Case}
\newtheorem{claim}{Claim}
\newtheorem{conclusion}{Conclusion}
\newtheorem{condition}{Condition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{criterion}{Criterion}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{exercise}{Exercise}
\newtheorem{lemma}{Lemma}
\newtheorem{notation}{Notation}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}
\newtheorem{solution}{Solution}
\newtheorem{summary}{Summary}
\numberwithin{equation}{section}

\input{tcilatex}

\begin{document}
\title{GEOCAM Tutorial}
\author{Daniel Champion, Taylor Johnson}
\maketitle

Welcome to the GEOCAM tutorial. \ This document will guide you through
several of the fundamental components of the project's code. \ The code that
appears in this document can be found in the file tutorialcode.cpp in the
LabManual directory. \ We recommend that the reader executes the relevant
portions of the code while reading through this document to fully utilize
the tutorial.

A myriad of functions have been created in the project in order to expand
our research. \ To access these functions (as a developer) it is necessary
to add them to your project as well as provide all necessary "include"
statements in your code. \ \texttt{tutorialcode.cpp} contains excellent
examples of this practice. 

The first function from the project that we will use allows us to load a
"Lutz" format triangulation. \ These triangulations are available for
download at \url{http://www.math.tu-berlin.de/diskregeom/stellar/}; these
triangulations specify only the top dimensional simplices in a
triangulation. \ To begin, a file is created to store the triangulation.%
\newline
\begin{verbatim}
//Store Lutz format triangulation in a file:
char filename[] = "Data/3DManifolds/LutzFormat/manifold_3_7_1.txt";
\end{verbatim}

\bigskip 

Another file will be created to store the standard format version of the
triangulation. \ The standard format contains a list of all simplices
(including sub-simplices) along with all "local" information for each
simplex.\newline
\begin{verbatim}
//Create file to store standard format triangulation:
char modified[] = "Data/3DManifolds/StandardFormat/manifold_3_7_1.txt";
\end{verbatim}

\bigskip 

Once the Lutz triangulation is loaded it is necessary to convert it to
standard format. In the case of 2D triangulations this is done by calling
the function \verb|makeTriangulationFile|, in the case of 3D triangulations 
\verb|make3DTriangulationFile| is used. \ To learn more about these
functions see the wiki entry on \verb|makeTriangulationFile|.\newline
\begin{verbatim}
// Convert from Lutz format to standard format:
makeTriangulationFile("./tetra_lutz.txt", "./tetra_standard.txt");
 
// Now read in the triangulation from standard format:
readTriangulationFile("./tetra_standard.txt");
\end{verbatim}

\bigskip 

Now that the standard format triangulation is loaded into the code it is
possible to investigate the combinatorial properties of a triangulation. \
As an example, we will determine and print out the number of vertices, edges
and faces using the Triangulation class.\newline
\begin{verbatim}
//Determine the number of vertices edges and faces:
int vertSize = Triangulation::vertexTable.size();
int edgeSize = Triangulation::edgeTable.size();
int faceSize = Triangulation::faceTable.size();
 
printf("V = %d, E = %d, F = %d\n", vertSize, edgeSize, faceSize);
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

Using the number of vertices, edges, and faces it is possible to determine
the Euler Characteristic of this 2D manifold.\newline
\begin{verbatim}
int EulerCharacteristic = vertSize - edgeSize + faceSize;
printf("Euler Characteristic = %d\n", EulerCharacteristic);
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

The triangulation we loaded is just the triangulation of a tetrahedron, and
hence is topologically equivalent to a sphere (hence the Euler
characteristic is 2). \ It is also possible to determine the local vertices,
edges, or faces using commands from the triangulation class using a command
such as:

\texttt{Triangulation::edgeTable[i].getLocalFaces()}

The next example will find the local faces of each edge in the triangulation
by storing them as pointers to vectors. \newline
\begin{verbatim}
//Vector to store local faces:
vector <int>* LF:
 
//For loop to iterate over all edges of triangulation:
for(int i = 1; i <= edgeSize; i++) {
   LF = Triangulation::edgeTable[i].getLocalFaces();
   printf("Faces sharing edge %d are:\n", i);
   //for loop to print out each local face that shares the edge i:
      for (int n = 0; n < (*(LF)).size(); n++) {
      printf("%d\n", LF -> at(n));}
   }
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

During each iteration of the code written above, the two faces that share
edge \verb|i| are stored in the vector \verb|LF| and then printed out for
viewing. \ The astute reader will note that since we are investigation a
manifold, each edge will have exactly two local faces.

Two important geometric quantities that are given to a triangulation are
radii and etas. \ For each vertex, it is possible to retrieve and set the
value of the radius.  In the next example the radii will be set to be 2. \
The value of the radii will then be retrieved using \verb|valueAt|. \newline
\begin{verbatim}
//The for loop iterates over all vertices:
for(int j = 1; j <= vertSize; j++){
//Sets value of radius at vertex j:
Radius::At(Triangulation::vertexTable[j]) -> setValue(2);
//Use valueAt to retrieve value of a radius:
double tempRadius = Radius::valueAt(Triangulation::vertexTable[j]);
printf("Radius at vertex %d is: %f\n", j, tempRadius);
}
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

The tetrahedron triangulation we have been using has four vertices. \
Although in the above example the vertices are stored as the integers
\{1,2,3,4\} in general it is possible that the vertices are not stored in
consecutive order nor beginning with the number 1. The later case would be a
problem for all of the above "for loops" because they assume a starting
value of \verb|j|=\verb|1|.

In order to work around this problem we will create iterators for the edges,
faces, and vertices. These iterators are maps that iterate over all of the
edges, faces, or vertices of the given triangulation. \newline
\begin{verbatim}
//Each map iterates over the given triangulation characteristic:
map<int, Vertex>::iterator vit;
map<int, Edge>::iterator eit;
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

In the case of \verb|map<int, Face>::iterator fit;| the first entry of the
map, \verb|int|, stores the serial number of the face. The second entry of
the map, \verb|Face|, stores the actual face of the triangulation. \ As an
example of the use of these iterators, we will provide a "safer" way of
accomplishing the same task of setting the radii as above.\newline
\begin{verbatim}
//We use an iterator to vary over all of the vertices:
for(vit = Triangulation::vertexTable.begin();
    vit != Triangulation::vertexTable.end(); vit++){
//Sets value of radius at vertex j:
Radius::At(vit->second)-> setValue(2);
//Use valueAt to retrieve value of a radius:
double tempRadius = Radius::valueAt(vit->second);
printf("Radius at vertex %d is: %f\n", j, tempRadius);
}
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

Notice that we access the vertices using the code: \texttt{vit-\TEXTsymbol{>}%
second} instead of the lengthy code we used earlier: \texttt{%
Triangulation::vertexTable[j]}. If we wanted to use the lengthy version
using the iterator, we would use:

\texttt{Triangulation::vertexTable[vit-\TEXTsymbol{>}first]}, where the
fragment \texttt{vit-\TEXTsymbol{>}first }accesses the correct serial number
for the vertex. \ 

Next, we will use iterators again to load the values of the etas for all of
the edges. \ So as not to bore the reader, the code below shows how we can
vary the values of the etas as we index through with the iterator. \ \newline
\begin{verbatim}
int k=1;
for(eit=Triangulation::edgeTable.begin();
    eit!=Triangulation::edgeTable.end(); eit++, k++){
//The actual edge of the triangle is used to set the value of Eta:
Eta::At(eit->second)->setValue(2 * k);
printf("Eta at edge %d is: %f\n", eit->first, Eta::valueAt(eit->second));
}
pause("press ENTER to continue");
\end{verbatim}

\bigskip 

After setting the values of the radii and etas, other geometric quantities
can be calculated that depend on them. \ As an example, we will calculate
the edge lengths using the formula:%
\begin{equation*}
l_{ij}^{2}=r_{i}^{2}+r_{j}^{2}+2r_{i}r_{j}\eta _{ij}.
\end{equation*}

The calculation below will explicitly perform the calculation above. \
However, this calculation has been implemented in the project as a geoquant
and hence we will compare our calculation to the geoquant value. \ Take note
of how the geoquant is accessed, it should remind you of how we accessed the
radii and eta values. \ Indeed, radii and etas are also stored as geoquants
in the project, as are all geometric quantities. \ \newline
\begin{verbatim}
//Vector to store local vertices:
Vector <int>* LV;
for(eit = Triangulation::edgeTable.begin();
    eit!=Triangulation::edgeTable.end(); eit++){
double Etaij;
LV = (eit -> second).getLocalVertices();
Etaij = Eta::valueAt(eit -> second);
double ri;
double rj;
double temp;
ri = Radius::valueAt(Triangulation::vertexTable[LV -> at(0)]);
rj = Radius::valueAt(Triangulation::vertexTable[LV -> at(1)]);
temp = (ri * ri) + (rj *  rj) + (2 * ri * rj * Etaij);
temp = sqrt(temp);
printf("Length at edge %d is: %f\n", eit -> first, temp);
printf("Geoquant length is: %f\n", Length::valueAt(eit -> second));
}
pause("press ENTER to continue");
\end{verbatim}

Geoquants are the most commonly used calculations in the project. \ All
geoquants can be acquired using the code:\newline
\begin{verbatim}
ExampleGeoquant::valueAt(vertex1, edge1, edge2,...);
\end{verbatim}

\bigskip 

The objects: \texttt{vertex1, edge1, edge2,...} are different for each
geoquant, and thus we are not able to provide the exact input in general. \
For example, we input an edge when calculating length, however we would
input a face when calculating area. \ 

\end{document}
